# -*- coding: utf-8 -*-
"""fuzzy_score.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a5QgMNE5IFW4R41s6NecuCSfF1m5s6SE
"""

import numpy as np
import pandas as pd
import skfuzzy as fuzz

# === Membership Functions === #
def gaussian_membership(x, mean, sigma):
    return np.exp(-((x - mean) * 2) / (2 * sigma * 2))

def create_membership_functions():
    x_input = np.linspace(0, 1, 100)
    x_out_2 = np.linspace(0, 2, 100)
    x_out_8 = np.linspace(0, 8, 100)

    sigma = 0.1
    input_low = gaussian_membership(x_input, 0.2, sigma)
    input_med = gaussian_membership(x_input, 0.5, sigma)
    input_high = gaussian_membership(x_input, 0.8, sigma)

    out2 = {
        "vlow": fuzz.trapmf(x_out_2, [0, 0, 0.25, 0.5]),
        "low": fuzz.trapmf(x_out_2, [0.5, 0.75, 1, 1]),
        "med": fuzz.trapmf(x_out_2, [1, 1.25, 1.5, 1.75]),
        "high": fuzz.trapmf(x_out_2, [1.75, 2, 2, 2])
    }

    out8 = {
        "vlow": fuzz.trapmf(x_out_8, [0, 0, 1, 2]),
        "low": fuzz.trapmf(x_out_8, [2, 3, 4, 5]),
        "med": fuzz.trapmf(x_out_8, [4, 5, 6, 7]),
        "high": fuzz.trapmf(x_out_8, [6, 7, 8, 8])
    }

    return x_input, x_out_2, x_out_8, input_low, input_med, input_high, out2, out8

def fuzzify_input(value, x_input, membership_func):
    return np.interp(value, x_input, membership_func)

def apply_fuzzy_rules(question_type, sem, rel, coh, x_input, input_low, input_med, input_high, x_out_2, x_out_8, out2, out8):
    s = [fuzzify_input(sem, x_input, mf) for mf in (input_low, input_med, input_high)]
    r = [fuzzify_input(rel, x_input, mf) for mf in (input_low, input_med, input_high)]
    c = [fuzzify_input(coh, x_input, mf) for mf in (input_low, input_med, input_high)]

    if question_type == "2":
        output = np.zeros_like(x_out_2)
        output = np.maximum(output, np.minimum(np.minimum(s[2], c[2]), r[1]) * out2["high"])
        output = np.maximum(output, np.minimum(np.minimum(s[2], c[2]), r[2]) * out2["high"])
        output = np.maximum(output, np.minimum(np.minimum(s[1], c[1]), r[1]) * out2["med"])
        output = np.maximum(output, np.maximum(s[0], c[0]) * out2["vlow"])
        output = np.maximum(output, np.minimum(np.minimum(s[2], c[1]), r[1]) * out2["med"])
        output = np.maximum(output, np.minimum(np.minimum(s[1], c[2]), r[2]) * out2["high"])
        return fuzz.defuzz(x_out_2, output, 'centroid')

    elif question_type == "8":
        output = np.zeros_like(x_out_8)
        output = np.maximum(output, np.minimum(np.minimum(s[2], c[2]), r[1]) * out8["high"])
        output = np.maximum(output, np.minimum(np.minimum(s[2], c[2]), r[2]) * out8["high"])
        output = np.maximum(output, np.minimum(np.minimum(s[1], c[1]), r[1]) * out8["med"])
        output = np.maximum(output, np.maximum(s[0], c[0]) * out8["low"])
        output = np.maximum(output, np.minimum(np.minimum(s[2], c[1]), r[1]) * out8["med"])
        output = np.maximum(output, np.minimum(np.minimum(s[1], c[2]), r[2]) * out8["high"])
        return fuzz.defuzz(x_out_8, output, 'centroid') if np.sum(output) else x_out_8[0]

# === Core Pipeline === #
def generate_crisp_scores(input_file, output_file):
    df = pd.read_excel(input_file)
    x_input, x_out_2, x_out_8, ilow, imed, ihigh, out2, out8 = create_membership_functions()

    scores = []
    for _, row in df.iterrows():
        qtype = "2" if 1 <= row['Question Number'] <= 5 else "8"
        score = apply_fuzzy_rules(qtype, row['Final Similarity Score'], row['Relevance'], row['Coherence'],
                                   x_input, ilow, imed, ihigh, x_out_2, x_out_8, out2, out8)
        scores.append(round(score, 2))

    df["Crisp Score"] = scores
    df.to_excel(output_file, index=False)
    print(f"Crisp scores saved to {output_file}")
    return output_file

def round_scores(input_file, output_file):
    df = pd.read_excel(input_file)
    allowed_marks = np.arange(0.25, 8.25, 0.25)
    df['Final Score'] = df['Crisp Score'].apply(lambda score: allowed_marks[np.abs(allowed_marks - score).argmin()])
    df.to_excel(output_file, index=False)
    print(f"Rounded scores saved to {output_file}")
    return output_file

def calculate_total_marks(input_file, output_file):
    df = pd.read_excel(input_file)
    df["Marks Obtained out of 50"] = ""
    total_marks = df.groupby("StudentID")["Final Score"].sum().round()
    for sid in df["StudentID"].unique():
        df.loc[df["StudentID"] == sid, "Marks Obtained out of 50"] = total_marks[sid] if sid in total_marks else ""
    df.to_excel(output_file, index=False)
    print(f"Total marks saved to {output_file}")
    return output_file

def convert_to_100(input_file, output_file):
    df = pd.read_excel(input_file)
    df["Marks Obtained out of 50"] = pd.to_numeric(df["Marks Obtained out of 50"], errors='coerce')
    df["Marks obtained out of 100"] = df["Marks Obtained out of 50"] * 2
    df.to_excel(output_file, index=False)
    print(f"Marks out of 100 saved to {output_file}")
    return output_file

def assign_grades(input_file, output_file):
    df = pd.read_excel(input_file)
    df["Marks obtained out of 100"] = pd.to_numeric(df["Marks obtained out of 100"], errors="coerce")
    def grade(m):
        if pd.isna(m): return ""
        elif m >= 90: return "O"
        elif m >= 80: return "A+"
        elif m >= 70: return "A"
        elif m >= 60: return "B+"
        elif m >= 50: return "B"
        else: return "F"
    df["Grade"] = df["Marks obtained out of 100"].apply(grade)
    df.to_excel(output_file, index=False)
    print(f"Grades saved to {output_file}")
    return output_file

def calculate_confidence(input_file, output_file):
    df = pd.read_excel(input_file)
    df["Marks obtained out of 100"] = pd.to_numeric(df["Marks obtained out of 100"], errors="coerce")
    df["Confidence Score"] = (df["Marks obtained out of 100"] / 10).round(2)
    df.to_excel(output_file, index=False)
    print(f"Confidence Score saved to {output_file}")
    return output_file